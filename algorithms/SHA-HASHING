import streamlit as st
import hashlib
import base64
import secrets
from typing import Optional, Tuple
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

class CryptoError(Exception):
    pass

class SHACrypto:
    HASH_ALGORITHMS = {
        'sha256': hashlib.sha256,
        'sha512': hashlib.sha512,
        'sha1': hashlib.sha1,
        'md5': hashlib.md5
    }

    def __init__(self):
        self.backend = default_backend()

    def derive_key_iv(self, password: str, salt: Optional[bytes] = None) -> Tuple[bytes, bytes, bytes]:
        if salt is None:
            salt = secrets.token_bytes(16)
        key_material = hashlib.sha256(password.encode() + salt).digest()
        key = key_material[:32]
        iv = key_material[16:32]
        return key, iv, salt

    def encrypt_text(self, text: str, password: str) -> str:
        try:
            salt = secrets.token_bytes(16)
            key, iv, _ = self.derive_key_iv(password, salt)
            padder = padding.PKCS7(algorithms.AES.block_size).padder()
            padded_data = padder.update(text.encode()) + padder.finalize()
            cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=self.backend)
            encryptor = cipher.encryptor()
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()
            return base64.b64encode(salt + ciphertext).decode('utf-8')
        except Exception as e:
            raise CryptoError(f"Encryption failed: {str(e)}")

    def decrypt_text(self, encrypted_text: str, password: str) -> str:
        try:
            raw_data = base64.b64decode(encrypted_text)
            salt = raw_data[:16]
            ciphertext = raw_data[16:]
            key, iv, _ = self.derive_key_iv(password, salt)
            cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=self.backend)
            decryptor = cipher.decryptor()
            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
            unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
            plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
            return plaintext.decode('utf-8')
        except Exception as e:
            raise CryptoError(f"Decryption failed: {str(e)}")

    def hash_text(self, text: str, algorithm: str = 'sha256') -> str:
        if algorithm not in self.HASH_ALGORITHMS:
            raise ValueError(f"Invalid algorithm. Choose from: {', '.join(self.HASH_ALGORITHMS.keys())}")
        hash_func = self.HASH_ALGORITHMS[algorithm]()
        hash_func.update(text.encode('utf-8'))
        return hash_func.hexdigest()

def read_uploaded_file(uploaded_file) -> str:
    try:
        content = uploaded_file.read()
        return content.decode('utf-8')
    except Exception:
        st.error("Error reading uploaded file. Please upload a valid text file (.txt).")
        return ""

def create_download_link(text: str, filename: str) -> None:
    b64 = base64.b64encode(text.encode()).decode()
    href = f'<a href="data:file/txt;base64,{b64}" download="{filename}">⬇️ Download Result as file</a>'
    st.markdown(href, unsafe_allow_html=True)

st.title("SHACrypto Web tool ")

crypto = SHACrypto()

operation = st.radio("Choose an operation:", ["Encrypt Text", "Decrypt Text", "Hash Text"])

password = st.text_input("Enter password/key:", type="password", value="default123")

uploaded_file = st.file_uploader("Or upload a text file (.txt):", type=['txt'])

input_text = ""
if uploaded_file is not None:
    input_text = read_uploaded_file(uploaded_file)
    st.text_area("Input text from file:", value=input_text, height=150)
else:
    input_text = st.text_area("Or enter text here:", height=150)

if operation == "Encrypt Text":
    if st.button("Encrypt"):
        if not input_text.strip():
            st.error("Please provide text to encrypt (either type or upload file).")
        elif not password:
            st.error("Please enter a password.")
        else:
            try:
                encrypted = crypto.encrypt_text(input_text, password)
                st.success("Encrypted Text:")
                st.code(encrypted)
                create_download_link(encrypted, "encrypted.txt")
            except Exception as e:
                st.error(f"Encryption failed: {e}")

elif operation == "Decrypt Text":
    if st.button("Decrypt"):
        if not input_text.strip():
            st.error("Please provide text to decrypt (either type or upload file).")
        elif not password:
            st.error("Please enter a password.")
        else:
            try:
                decrypted = crypto.decrypt_text(input_text, password)
                st.success("Decrypted Text:")
                st.code(decrypted)
                create_download_link(decrypted, "decrypted.txt")
            except Exception as e:
                st.error(f"Decryption failed: {e}")

else: 
    algo = st.selectbox("Select hash algorithm:", options=["sha256", "sha512", "sha1", "md5"])
    if st.button("Generate Hash"):
        if not input_text.strip():
            st.error("Please provide text to hash (either type or upload file).")
        else:
            try:
                hashed = crypto.hash_text(input_text, algo)
                st.success(f"Hash ({algo}):")
                st.code(hashed)
                create_download_link(hashed, f"hash_{algo}.txt")
            except Exception as e:
                st.error(f"Hashing failed: {e}")
