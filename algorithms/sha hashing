import hashlib
import base64
import secrets
from typing import Optional, Tuple
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend

class CryptoError(Exception):
    """Custom exception for cryptography operations"""
    pass

class SHACrypto:
    HASH_ALGORITHMS = {
        'sha256': hashlib.sha256,
        'sha512': hashlib.sha512,
        'sha1': hashlib.sha1,
        'md5': hashlib.md5
    }

    def __init__(self):
        self.backend = default_backend()

    def derive_key_iv(self, password: str, salt: Optional[bytes] = None) -> Tuple[bytes, bytes, bytes]:
        if salt is None:
            salt = secrets.token_bytes(16)
        key_material = hashlib.sha256(password.encode() + salt).digest()
        key = key_material[:32]
        iv = key_material[16:32]
        return key, iv, salt

    def encrypt_text(self, text: str, password: str) -> str:
        try:
            salt = secrets.token_bytes(16)
            key, iv, _ = self.derive_key_iv(password, salt)
            padder = padding.PKCS7(algorithms.AES.block_size).padder()
            padded_data = padder.update(text.encode()) + padder.finalize()
            cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=self.backend)
            encryptor = cipher.encryptor()
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()
            return base64.b64encode(salt + ciphertext).decode('utf-8')
        except Exception as e:
            raise CryptoError(f"Encryption failed: {str(e)}")

    def decrypt_text(self, encrypted_text: str, password: str) -> str:
        try:
            raw_data = base64.b64decode(encrypted_text)
            salt = raw_data[:16]
            ciphertext = raw_data[16:]
            key, iv, _ = self.derive_key_iv(password, salt)
            cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=self.backend)
            decryptor = cipher.decryptor()
            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
            unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
            plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
            return plaintext.decode('utf-8')
        except Exception as e:
            raise CryptoError(f"Decryption failed: {str(e)}")

    def hash_text(self, text: str, algorithm: str = 'sha256') -> str:
        if algorithm not in self.HASH_ALGORITHMS:
            raise ValueError(f"Invalid algorithm. Choose from: {', '.join(self.HASH_ALGORITHMS.keys())}")
        hash_func = self.HASH_ALGORITHMS[algorithm]()
        hash_func.update(text.encode('utf-8'))
        return hash_func.hexdigest()
#Main Menu
def main_menu():
    crypto = SHACrypto()
    default_password = "default123" 

    print("\nChoose an operation:")
    print("1. Encrypt text")
    print("2. Decrypt text")
    print("3. Hash text")

    choice = input("Enter your choice (1-3): ").strip()

    try:
        if choice == "1":
            text = input("Enter text to encrypt: ")
            print("Encrypted:", crypto.encrypt_text(text, default_password))

        elif choice == "2":
            text = input("Enter text to decrypt: ")
            print("Decrypted:", crypto.decrypt_text(text, default_password))

        elif choice == "3":
            text = input("Enter text to hash: ")
            algo = input("Hash algorithm (sha256, sha512, sha1, md5): ").strip()
            print(f"Hashed ({algo}):", crypto.hash_text(text, algo))

        else:
            print("Invalid choice.")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main_menu()
